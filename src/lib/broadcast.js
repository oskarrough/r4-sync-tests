import {playTrack, seekTo} from '$lib/api'
import {appState} from '$lib/app-state.svelte'
import {logger} from '$lib/logger'
import {sdk} from '@radio4000/sdk'
import {broadcastsCollection, channelsCollection, tracksCollection, ensureTracksLoaded} from '$lib/tanstack/collections'

const log = logger.ns('broadcast').seal()

/** @param {string} channelId */
function isV1Channel(channelId) {
	return channelsCollection.get(channelId)?.source === 'v1'
}

/** @param {string} trackId */
function isV1Track(trackId) {
	const track = tracksCollection.get(trackId)
	if (!track) return false
	const channel = [...channelsCollection.state.values()].find((ch) => ch.slug === track.slug)
	return channel?.source === 'v1'
}

/** Supabase channel for listening to a single broadcast's updates
 * @type {any}
 */
let broadcastChannel = null

/** @param {string} channelId */
export async function joinBroadcast(channelId) {
	try {
		const {data} = await sdk.supabase.from('broadcast').select('*').eq('channel_id', channelId).single().throwOnError()

		// Prefetch all tracks for this channel
		const broadcast = broadcastsCollection.state.get(channelId)
		const slug = broadcast?.channels.slug
		if (slug) {
			ensureTracksLoaded(slug)
			log.log('prefetching_tracks', {slug})
		}

		await playBroadcastTrack(data)
		startBroadcastSync(channelId)
		log.log('joined', {channelId})
	} catch (error) {
		log.error('join_failed', {
			channelId,
			error: /** @type {Error} */ (error).message
		})
	}
}

export function leaveBroadcast() {
	stopBroadcastSync()
	appState.listening_to_channel_id = undefined
	appState.is_playing = false
	log.log('left')
}

/**
 * Helper to upsert a broadcast record
 * @param {string} channelId
 * @param {string} trackId
 */
export async function upsertRemoteBroadcast(channelId, trackId) {
	return sdk.supabase
		.from('broadcast')
		.upsert(
			{
				channel_id: channelId,
				track_id: trackId,
				track_played_at: new Date().toISOString()
			},
			{onConflict: 'channel_id'}
		)
		.throwOnError()
}

/**
 * @param {string} channelId
 * @param {string} [trackId]
 */
export async function startBroadcast(channelId, trackId) {
	log.log('start_requested', {channelId, trackId})

	if (!trackId) {
		log.log('skipped_no_track', {channelId})
		return
	}
	if (isV1Channel(channelId)) {
		throw new Error('Legacy channels cannot broadcast')
	}
	if (isV1Track(trackId)) {
		throw new Error('This track is from a legacy channel and cannot be streamed live')
	}

	await upsertRemoteBroadcast(channelId, trackId)
	log.log('created', {channelId, trackId})
}

/**
 * @param {string} channelId
 */
export async function stopBroadcast(channelId) {
	log.log('stop_requested', {channelId})
	if (!channelId) return
	try {
		await sdk.supabase.from('broadcast').delete().eq('channel_id', channelId).throwOnError()
		log.log('deleted remote broadcast', {channelId})
	} catch (error) {
		log.error('failed to delete remote broadcast', {
			channelId,
			error: /** @type {Error} */ (error).message
		})
	}
}

/** @param {string} channelId */
function startBroadcastSync(channelId) {
	stopBroadcastSync()

	log.log('starting_sync', {channelId})

	broadcastChannel = sdk.supabase
		.channel(`broadcast:${channelId}`)
		.on(
			'postgres_changes',
			{
				event: 'UPDATE',
				schema: 'public',
				table: 'broadcast',
				filter: `channel_id=eq.${channelId}`
			},
			(payload) => {
				const broadcast = /** @type {import('$lib/types').Broadcast} */ (payload.new)
				log.log('change_received', {
					channelId,
					track_id: broadcast.track_id,
					track_played_at: broadcast.track_played_at,
					payload_event: payload.eventType
				})
				playBroadcastTrack(broadcast)
			}
		)
		.subscribe((status) => {
			log.log('subscription_status', {channelId, status})
		})
}

function stopBroadcastSync() {
	if (broadcastChannel) {
		log.log('stopping_sync')
		broadcastChannel.unsubscribe()
		broadcastChannel = null
	}
}

/**
 * Calculate elapsed seconds from track_played_at
 * @param {import('$lib/types').Broadcast} broadcast
 * @param {import('$lib/types').Track} track
 * @returns {number|undefined}
 */
function calculateSeekTime(broadcast, track) {
	if (!broadcast.track_played_at || !track.duration) return undefined
	const elapsed = (Date.now() - new Date(broadcast.track_played_at).getTime()) / 1000
	if (elapsed < 0 || elapsed >= track.duration) return undefined
	return Math.floor(elapsed)
}

/**
 * @param {import('$lib/types').Broadcast} broadcast
 */
async function playBroadcastTrack(broadcast) {
	const {track_id, channel_id} = broadcast

	// Check if track is already loaded
	let track = tracksCollection.get(track_id)
	if (!track) {
		// Track not loaded - fetch it directly by ID
		try {
			const {data, error} = await sdk.tracks.readTrack(track_id)
			if (error || !data) throw new Error(`Track ${track_id} not found`)
			tracksCollection.utils.writeUpsert(/** @type {import('$lib/types').Track} */ (data))
			track = /** @type {import('$lib/types').Track} */ (data)
		} catch (error) {
			log.error('failed_to_play', {track_id, channel_id, error: /** @type {Error} */ (error).message})
			return false
		}
	}

	const seekTime = calculateSeekTime(broadcast, track)
	log.log('play_broadcast_track', {track_id, seekTime})
	await playTrack(track_id, null, 'broadcast_sync')
	if (seekTime) seekTo(seekTime)
	appState.listening_to_channel_id = channel_id
	return true
}

/** Validate that listening_to_channel_id points to an active broadcast */
export async function validateListeningState() {
	if (!appState.listening_to_channel_id) return

	try {
		const {data} = await sdk.supabase
			.from('broadcast')
			.select('channel_id')
			.eq('channel_id', appState.listening_to_channel_id)
			.single()

		if (!data) {
			appState.listening_to_channel_id = undefined
		}
	} catch {
		appState.listening_to_channel_id = undefined
	}
}
