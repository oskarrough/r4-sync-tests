# R5 CLI - Ultra-Minimal Download Tool

## Philosophy
Unix composability: Small tools that do one thing well, output JSON, compose via pipes.
The filesystem IS the database. YAGNI - You Ain't Gonna Need It (until you do).

  The key insight is that we're building Unix-style tools that:
  - Output JSON for easy piping and composition
  - Let the filesystem be the state (no database needed)
  - Delegate the hard work to yt-dlp (skip existing, retries, format selection)
  - Stay under 500 lines total

  The beauty is in the simplicity: three commands that compose naturally with jq, grep, xargs, and other Unix tools. No complex state management, no database synchronization -
  just pure data transformation functions that pipe together.

## Core Commands (MVP)

```
r5 channel <slug>    → outputs channel JSON to STDOUT
r5 tracks <slug>     → outputs tracks JSON array to STDOUT  
r5 download          → reads track JSON from STDIN, calls yt-dlp
```

## Implementation Plan

### Phase 1: Core Functions (MVP)
1. Create `cli/src/r5-fetch.ts`
   - Import r4 from main app (no PGlite dependency)
   - Copy minimal v1 fetching logic from r5.ts
   - fetchChannel(slug) → try r4, fallback to v1
   - fetchTracks(slug) → try r4, fallback to v1

2. Create `cli/src/commands/channel.ts`
   - Parse args: slug
   - Call fetchChannel
   - Output JSON to STDOUT

3. Create `cli/src/commands/tracks.ts`
   - Parse args: slug, optional limit
   - Call fetchTracks
   - Output JSON to STDOUT

4. Create `cli/src/commands/download.ts`
   - Read JSON from STDIN (tracks array or single track)
   - For each track: call yt-dlp with track.url
   - Let yt-dlp handle: skip existing, retries, format selection
   - Output results to STDERR (progress) and STDOUT (summary)

### Phase 2: Composition Examples

```bash
# View data
r5 channel oskar
r5 tracks oskar | jq '.[0:5]'

# Download all
r5 tracks oskar | r5 download

# Download first 10
r5 tracks oskar | jq '.[0:10]' | r5 download

# Filter and download
r5 tracks oskar | jq '.[] | select(.title | test("jazz"; "i"))' | r5 download

# Check what's downloaded (filesystem query)
ls ~/Music/r5/oskar/*.m4a | wc -l

# Pipe to other tools
r5 tracks oskar | jq -r '.[].url' | xargs -I {} yt-dlp {}
```

## What We DON'T Need (Yet)

- ❌ SQLite database - filesystem has the state
- ❌ Complex schemas - just Channel and Track types from main app
- ❌ Download tracking - yt-dlp skips existing files
- ❌ Sync logic - it's just fetch and download
- ❌ Progress database - use filesystem: file exists = downloaded
- ❌ Error recovery database - yt-dlp handles retries

## Future (Only If Needed)

- Add `r5 status` to check download status (just checks filesystem)
- Add `--folder` flag to download command
- Add SQLite ONLY if we need: metadata search, play counts, custom tags
- Add resume/queue features if batch downloads need pause/resume

## Key Principles

1. **Output is Interface**: Everything outputs JSON for composition
2. **No Hidden State**: No side effects without explicit command
3. **Filesystem = Truth**: Downloaded files ARE the database
4. **Delegate Complexity**: Let yt-dlp handle the hard parts
5. **Pure Functions**: Each command is a data transformer
6. **Start Simple**: Ship MVP, add features based on real usage

## Technical Notes

- Use r4.ts from main app (it has no PGlite dependency)
- Copy only necessary v1 functions (readFirebaseChannelTracks)
- Output JSON to STDOUT, progress/logs to STDERR
- Commands are stateless and idempotent
- Let yt-dlp handle: format selection, existing files, retries

## Success Metrics

✅ Can fetch any channel (r4 or v1)
✅ Can pipe tracks to jq for filtering  
✅ Can download tracks without re-downloading
✅ Works with standard Unix tools
✅ No database setup required
✅ Under 500 lines of code total
